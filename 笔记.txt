session共享问题：多台tomcat并不共享session存储空间，当请求切换到不同tomcat服务时会导致数据丢失问题
替代方案应该满足：
    1.数据共享
    2.内存存储
    3.key、value结构

redis实现共享session登录
    保存用户信息到redis中，设置键值对
    key不能使用手机号，原因是直接将key返回到前端可能有泄露的风险

redis存较长hash类型的数据用putall，取用entries

为了避免登陆后访问不被拦截的页面时，token有效期到了也被踢出出，设置双重拦截器，拦截所有请求，只要有请求就刷新token
调用拦截器的order方法可以控制拦截器的执行顺序：order:越小越先执行

缓存：
    1.什么是缓存：数据交换的缓冲区，存储数据的临时地方，读写性能较高
    2.缓存的作用：降低后端负载，提高读写效率，降低响应时间
           成本：数据一致性成本，代码维护成本，运维成本

redis实在客户端与数据库之间加了一层缓存，大大降低了客户端请求对数据库的访问

缓存更新策略：
    内存淘汰：不用自己维护，利用redis的内存淘汰机制，当内存不足时自动淘汰部分数据，下次查询时更新缓存，
    （一致性差，维护成本无）
    超时剔除：给缓存数据添加ttl时间，到期后自动删除缓存，下次查询时更新缓存
    （一致性一般，维护成本低）
    主动更新：编写业务逻辑，在修改数据库同时，更新缓存
    （一致性好，维护成本高）
   低一致性需求：使用内存淘汰机制，例如店铺类型的查询缓存
   高一致性需求：主动更新，并以超时踢出作为兜底方案，例如店铺详情查询的缓存
    主动更新实现方式：1.由缓存的调用者在更新数据库时更新缓存
                   2.缓存与数据库整合成一个服务，有服务来维护一致性
                   3.写回：调用者之操作缓存，由其他线程异步地将缓存数据持久化到数据库

    三个问题需要考虑：1.删除缓存还是更新缓存：删除缓存：更新数据库时让缓存失效，查询时再更新缓存
                   2.如何保证缓存与数据库的操作同时成功或失败：使用原子事务
                   3.先操作缓存还是数据库：
                            先删缓存再操作数据库：异常情况发生率较高
                            先操作数据库再删缓存：异常情况发生率较低，限制性慢操作，再执行快操作，降低了中
                                              间有其他线程插入的可能

缓存穿透：客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远都不会生效，这些请求都会打到数据库
        如果多次请求这个不存在的数据，可能会导致数据库崩溃
    解决方案：
        1.缓存空对象：若数据库请求未命中，那么数据库向redis中缓存一个空对象
            优点：实现简单，维护方便
            缺点：额外内存消耗（可以设置短ttl），可能造成短期的不一致，若请求多个不存在的数据，这些请求还是会打到数据库
        2.布隆过滤：在客户端与redis之间加入布隆过滤器，每次请求都先访问布隆过滤器，若请求目标不存在则直接拒绝，存在放行
                它能够快速判断某个元素可能存在于集合中，或者肯定不存在于集合中。拒绝一定不在，放行不一定在
            优点：内存占用较少，没有多余的key
            缺点：实现复杂，存在误判
        3.主动避免：增加id复杂度，做好基础格式的校验 ，加强用户权限，做好热点参数的限流

缓存雪崩：在同一时间大量缓存key同时失效或者redis服务器宕机，导致大量请求到达数据库，带来巨大压力
    解决方案：
        1.给不同的key的ttl添加随机值
        2.利用redis集群提高服务的可用性
        3.给缓存业务添加降级限流策略
        4.给业务添加多级缓存

缓存击穿：热点key问题一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击
    解决方案：
        1.互斥锁，缺点：线程等待，死锁
        2.逻辑过期：不设置ttl，在value中写入有效期，若查询到过期了那么久新建一个线程来进行更新，在更新之前额的请求全部返回旧数据
                    （缺点：不保证一致性。额外内存消耗，实现复杂）


